package nowcoder.code.binary_search;
import nowcoder.code.binary_search.rotating_array.*;

/**
 * @author chenyuqun@zlongame.com
 * @date 2023/8/28
 *
 * 17 二分查找-I
 * 描述：
 *    请实现无重复数字的升序数组的二分查找
 *    给定一个元素升序的、无重复数字的整型数组 nums和一个目标值 target，写一个函数搜索nums中的target，如果目标值存在返回下标（下标从0开始），否则返回 -1
 *   {@link Bm17Solution#main(String[])}
 *
 * 18 二维数组中的查找
 * 描述：在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
 *[
 * [1,2,8,9],
 * [2,4,9,12],
 * [4,7,10,13],
 * [6,8,11,15]
 * ]
 * 给定 target = 7，返回 true。
 * 给定 target = 3，返回 false。
 * {@link Bm18Solution#main(String[])}
 *
 * 19 寻找峰值
 * 描述：
 * 给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。
 * 1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于。
 * 2.假设nums[-1] = nums[n] =−∞
 * 3.对于所有有效的 i 都有 nums[i] != nums[i + 1]
 * 4.你可以使用O(logN)的时间复杂度实现此问题吗？
 * {@link Bm19Solution#main(String[])}
 *
 * 20 数组中的逆序对(todo hard难度，可以多看看)
 * 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取
 * 模的结果输出。 即输出P mod 1000000007 数据范围： ; 对于 的数据, 对于 的数据, 数组中所有数字的值满足 要求：空间复杂度 ，时间复杂度
 *  Related Topics 数组
 * 示例:
 * 输入:[1,2,3,4,5,6,7,0]
 * 输出:7
 * {@link Bm20Solution#main(String[])}
 *
 * 21 旋转数组的最小数字
 * 有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4
 * ,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。
 * 数据范围：，数组中任意元素的值: 要求：空间复杂度： ，时间复杂度：
 * Related Topics 二分
 * 示例:
 * 输入:[3,4,5,1,2]
 * 输出:1
 * {@link Bm21Solution#main(String[])}
 *
 * 22 比较版本号(todo 待ac)
 * 牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等 现在给你2个版本号version1和version2，请你比较他们的大小 版本号是由
 * 修订号组成，修订号与修订号之间由一个"."连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版
 * 本号 每个版本号至少包含1个修订号。 修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。
 *  比较规则： 一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如"0.1"和"0.01"的版本
 * 号是相等的 二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，"1.1"的版本号小于"1.1.1"。因为"1.1"的版本号相当于"1.1.0
 * "，第3位修订号的下标为0，小于1 三. version1 > version2 返回1，如果 version1 < version2 返回-1，不然返回0.
 *  数据范围： version1 和 version2 的修订号不会超过int的表达范围，即不超过 32 位整数 的范围
 *  进阶： 空间复杂度 ， 时间复杂度
 *  Related Topics 字符串 双指针
 * 示例:
 * 输入:"1.1","2.1"
 * 输出:-1
 * {@link Bm22Solution#main(String[])}
 *
 * leetcode中的二分题目
 *    旋转数组专题
 *       参考：<a href="https://blog.csdn.net/wangquan1992/article/details/106696643">...</a>
 *          [189]轮转数组
 *          描述：{@link package_info#leetcode189()}
 *          AC:{@link LeetCode189#main(String[])}
 *          [33]搜索旋转排序数组
 *          描述:{@link package_info#leetcode33()}
 *          AC:{@link LeetCode33#main(String[])}
 *          [81]搜索旋转排序数组II
 *          描述:{@link package_info#leetcode81()}
 *          AC：{@link LeetCode81#main(String[])}
 *          [面试题 10.03]搜索旋转数组
 *          描述:{@link package_info#leetcode10_03()}
 *          AC:{@link LeetCode_1003#main(String[])}
 *          [153]寻找旋转排序数组中的最小值
 *          描述：{@link package_info#leetcode153()}
 *          AC:{@link LeetCode153#main(String[])}
 *          [154]寻找旋转排序数组中的最小值II
 *          描述：{@link package_info#leetcode154()}
 *          AC:{@link LeetCode154#main(String[])}
 *
 */
public class package_info {
    /**
     * 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
     * 示例 1:
     * 输入: nums = [1,2,3,4,5,6,7], k = 3
     * 输出: [5,6,7,1,2,3,4]
     * 解释:
     * 向右轮转 1 步: [7,1,2,3,4,5,6]
     * 向右轮转 2 步: [6,7,1,2,3,4,5]
     * 向右轮转 3 步: [5,6,7,1,2,3,4]
     * 示例 2:
     * 输入：nums = [-1,-100,3,99], k = 2
     * 输出：[3,99,-1,-100]
     * 解释:
     * 向右轮转 1 步: [99,-1,-100,3]
     * 向右轮转 2 步: [3,99,-1,-100]
     * 提示：
     * 1 <= nums.length <= 105
     * -231 <= nums[i] <= 231 - 1
     * 0 <= k <= 105
     * 进阶：
     * 尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。
     * 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？
     */
    public static void leetcode189() {}

    /**
     * 整数数组 nums 按升序排列，数组中的值 互不相同 。
     * 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
     * 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
     * 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。
     * 示例 1：
     * 输入：nums = [4,5,6,7,0,1,2], target = 0
     * 输出：4
     * 示例 2：
     * 输入：nums = [4,5,6,7,0,1,2], target = 3
     * 输出：-1
     * 示例 3：
     * 输入：nums = [1], target = 0
     * 输出：-1
     * 提示：
     * 1 <= nums.length <= 5000
     * -104 <= nums[i] <= 104
     * nums 中的每个值都 独一无二
     * 题目数据保证 nums 在预先未知的某个下标上进行了旋转
     * -104 <= target <= 104
     */
    public static void leetcode33() {}

    /**
     * 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
     * 在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
     * 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。
     * 你必须尽可能减少整个操作步骤。
     * 示例 1：
     * 输入：nums = [2,5,6,0,0,1,2], target = 0
     * 输出：true
     * 示例 2：
     * 输入：nums = [2,5,6,0,0,1,2], target = 3
     * 输出：false
     * 提示：
     * 1 <= nums.length <= 5000
     * -104 <= nums[i] <= 104
     * 题目数据保证 nums 在预先未知的某个下标上进行了旋转
     * -104 <= target <= 104
     * 进阶：
     * 这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。
     * 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？
     *
     */
    public static void leetcode81() {}

    /**
     * 搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。
     * 示例1:
     *  输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5
     *  输出: 8（元素5在该数组中的索引）
     * 示例2:
     *  输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11
     *  输出：-1 （没有找到）
     * 提示:
     * arr 长度范围在[1, 1000000]之间
     *
     */
    public static void leetcode10_03() {}

    /**
     * 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
     * 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
     * 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
     * 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
     * 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
     * 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。
     * 示例 1：
     * 输入：nums = [3,4,5,1,2]
     * 输出：1
     * 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
     * 示例 2：
     * 输入：nums = [4,5,6,7,0,1,2]
     * 输出：0
     * 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
     * 示例 3：
     * 输入：nums = [11,13,15,17]
     * 输出：11
     * 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
     * 提示：
     * n == nums.length
     * 1 <= n <= 5000
     * -5000 <= nums[i] <= 5000
     * nums 中的所有整数 互不相同
     * nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转
     *
     */
    public static void leetcode153() {}

    /**
     * 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
     * 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
     * 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
     * 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
     * 给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
     * 你必须尽可能减少整个过程的操作步骤。
     * 示例 1：
     * 输入：nums = [1,3,5]
     * 输出：1
     * 示例 2：
     * 输入：nums = [2,2,2,0,1]
     * 输出：0
     * 提示：
     * n == nums.length
     * 1 <= n <= 5000
     * -5000 <= nums[i] <= 5000
     * nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转
     * 进阶：这道题与 寻找旋转排序数组中的最小值 类似，但 nums 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？
     */
    //
    //
    public static void leetcode154() {}
}
