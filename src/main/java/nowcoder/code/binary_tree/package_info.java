package nowcoder.code.binary_tree;

import nowcoder.code.link.Link;

/**
 * 主要掌握二叉树的前序、中序、后序遍历，使用递归和迭代，层次遍历。
 *
 * 23、二叉树的前序遍历(todo 这三种遍历的迭代实现形式都挺复杂的，尤其是后序遍历，有时间多看看吧)
 * 描述：给定二叉树的根节点 root，返回它结点值的 前序 遍历。
 * {@link Bm23Solution)}
 *
 * 24、二叉树的中序遍历()
 * 描述：给定二叉树的根结点 root, 返回它结点值的 中序 遍历。
 * {@link Bm24Solution)}
 *
 * 25、二叉树的后序遍历()
 * 描述：给定二叉树的根结点 root, 返回它结点值的 后序 遍历。
 * {@link Bm25Solution)}
 *
 * 26、二叉树的层序遍历
 * 描述：给定二叉树的根节点 root, 返回它结点值的 层序遍历
 * {@link Bm26Solution)}
 *
 * 27、按之字形打印二叉树
 * 描述：给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）
 * {@link Bm27Solution)}
 *
 * 28、二叉树的最大深度
 * 描述：求给定二叉树的最大深度，
 *      深度是指树的根节点到任一叶子节点路径上节点的数量。
 *      最大深度是所有叶子节点的深度的最大值。
 *      （注：叶子节点是指没有子节点的节点。）
 *      这题还可以用BFS和DFS两种方法解决，之后学习到该专项后可以回头看看{@link Link#DFS} {@link Link#BFS}
 * {@link Bm28Solution}
 *
 * 29、二叉树中和为某一值的路径
 * 描述：给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。
 *     1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点
 *     2.叶子节点是指没有子节点的节点
 *     3.路径只能从父节点到子节点，不能从子节点到父节点
 *     4.总节点数目为n
 *{@link Bm29Solution}
 *
 * 30、二叉搜索树与双向链表
 * 描述：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。
 * 注意:
 *     1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继
 *     2.返回链表中的第一个节点的指针
 *     3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构
 *     4.你不用输出双向链表，程序会根据你的返回值自动打印输出
 * {@link Bm30Solution}
 *
 * 31、对称的二叉树
 * 描述：给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
 * {@link Bm31Solution}
 *
 * 32、合并二叉树
 * 描述：已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。
 * {@link Bm32Solution}
 *
 * // (todo 下面几个都挺复杂的，可以多看看)
 * 33、二叉树的镜像
 * 操作给定的二叉树，将其变换为源二叉树的镜像。
 * {@link Bm33Solution}
 *
 * 34、判断是不是二叉搜索树
 * 给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树
 * {@link Bm34Solution}
 *
 * 35、判断是不是完全二叉树
 * 给定一个二叉树，确定它是否是一个完全二叉树
 * 完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）
 * {@link Bm35Solution}
 *
 * 36、判断是不是平衡二叉树
 * 给定一个二叉数，确定它是否是一个平衡二叉树
 * 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树
 * 平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
 * {@link Bm36Solution}
 *
 * 37、二叉搜索树的最近公共祖先
 * 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
 * 1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.
 * 2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值
 * 3.所有节点的值都是唯一的。
 * 4.p、q 为不同节点且均存在于给定的二叉搜索树中。
 *{@link Bm37Solution}
 *
 * 38、在二叉树中找到两个节点的最近公共祖先
 * 给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。
 * 注：本题保证二叉树中每个节点的val值均不相同。
 *
 */
public class package_info {
}
